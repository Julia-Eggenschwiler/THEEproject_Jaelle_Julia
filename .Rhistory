for (i in 1:replicates) {
end_gen<-tail(which(!is.na(final_output[i,])), 1)
# if the length of end_gen is shorter than max_gen,then the Line will be colored grey
if (end_gen < max_gen){
line_col <- "grey"
# otherwise the line is colored randomly with another color
} else {
line_col <- lines_colors[i]
}
lines(x=1:max_gen,y=final_output[i,1:max_gen], col=line_col)
}
# set some Parameters to fixed Values
init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.01
m_rate_sm <- 0.01
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.05
s_sm <- 0.1
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.10,0.15,0.2)
s_values_sm <- c(0.25,0.30,0.35)
#Commented to vary always only one variable
#m_values_wm <- c(0.001,0.01,0.05)
#m_values_sm <- c(0.05,0.1,0.15)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
rescued = integer()
)
# preparing list to save mutation changes (in per cent) for all replicates - only if they exist
switch_stats_all <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
wb_to_wd = numeric(),
wd_to_wb = numeric(),
sb_to_sd = numeric(),
sd_to_sb = numeric()
)
library(dplyr)
library(ggplot2)
library(tidyr)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
#for(mval_wm in m_values_wm){
# for(mval_sm in m_values_sm){
# loop over Selection strength
for(sval_wm in s_values_wm){
for(sval_sm in s_values_sm){
# different Way of running many Simulations: make Replicates using "repeat" Function         with a counter i
# reset Counter
i<-1
repeat {
# increase Counter by one
i<-i+1
# defining total runs
total_runs <- total_runs + 1
# run the Simulation once
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, sval_sm, m_rate_wm,m_rate_sm, max_gen)
# determine total Population Sizes
pop_matrix <- one_run$population
total_size <- rowSums(pop_matrix)
# defining popuation matrix
pop_matrix <- one_run$population
# calculating total size (1 row is equal to total pop size, meaning adding up all columns)
total_size <- rowSums(pop_matrix)
# saving mutation changes
if (!is.null(one_run$switch_stats) && nrow(one_run$switch_stats) > 0) {
switch_stats <- one_run$switch_stats
switch_stats_all <- rbind(
switch_stats_all,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i-1,
wb_to_wd = switch_stats$wb_to_wd,
wd_to_wb = switch_stats$wd_to_wb,
sb_to_sd = switch_stats$sb_to_sd,
sd_to_sb = switch_stats$sd_to_sb
)
)
}
# determine final Population Size for each Mutant
N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
N_end_sd <- pop_matrix[nrow(pop_matrix), "sd"]
N_end_sb <- pop_matrix[nrow(pop_matrix), "sb"]
total_end <- N_end_wd + N_end_wb + N_end_sd + N_end_sb
# introduce rescue count
rescued_wd <- ifelse(N_end_wd > 0, 1, 0)
rescued_wb <- ifelse(N_end_wb > 0, 1, 0)
rescued_sd <- ifelse(N_end_sd > 0, 1, 0)
rescued_sb <- ifelse(N_end_sb > 0, 1, 0)
# save rescue outcome (rescue or extinction)
rescue_results <- rbind(rescue_results,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i - 1,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
)
)
# determine Frequencies of each mutant in the final Population
freq_wd <- ifelse(total_end > 0, N_end_wd / total_end, 0)
freq_wb <- ifelse(total_end > 0, N_end_wb / total_end, 0)
freq_sd <- ifelse(total_end > 0, N_end_sd / total_end, 0)
freq_sb <- ifelse(total_end > 0, N_end_sb / total_end, 0)
data_table_wd<- rbind(data_table_wd, c(sval_wm,freq_wd))
data_table_wb<- rbind(data_table_wb, c(sval_wm, freq_wb))
data_table_sd<- rbind(data_table_sd,c(sval_sm, freq_sd))
data_table_sb<-rbind(data_table_sb, c (sval_sm,freq_sb))
# enter the Data into the Table
data_table <- rbind(data_table,c(m_rate_wm = 0.001,m_rate_sm = 0.005,sval_wm,sval_sm,N_end_wd,N_end_wb, N_end_sd, N_end_sb,freq_wd, freq_wb, freq_sd,freq_sb)) # note that we add the varying Parameters (Mutation Rate and Selection Strength for each Version of weak and strong Mutation) to the Table too
# stop the repeated Computation after no_replicates times
if(i>no_replicates) break
}
}
}
#}
#}
# Population over generations
print(one_run$population)
# Mutation changes in percent
print(switch_stats_all)
# Make sure data is a proper data frame
data_table_wd <- as.data.frame(data_table_wd)
# If the column names are missing or wrong, set them
colnames(data_table_wd) <- c("V1", "V2")
# Add an Index Column for plotting along x-axis
data_table_wd$Index <- 1:nrow(data_table_wd)
# plotting Mutation Changes with different s values
switch_long <- switch_stats_all %>%
pivot_longer(cols = c(wb_to_wd, wd_to_wb, sb_to_sd, sd_to_sb),
names_to = "switch_type",
values_to = "percent")
ggplot(switch_long, aes(x = factor(s_wm), y = percent, fill = switch_type)) +
geom_boxplot() +
facet_wrap(~ switch_type) +
labs(x = "s_wm", y = "Percentage of total mutation events") +
theme_minimal()
# calculate Rescue Probability per Parameter Combination
rescue_summary <- rescue_results %>%
group_by(s_wm, s_sm) %>%
summarise(
rescue_prob_wd = mean(rescued_wd),
rescue_prob_wb = mean(rescued_wb),
rescue_prob_sd = mean(rescued_sd),
rescue_prob_sb = mean(rescued_sb),
.groups = "drop"
)
print(rescue_summary)
# Prepare rescue data
rescue_long <- rescue_summary %>%
pivot_longer(
cols = starts_with("rescue_prob_"),
names_to = "mutant",
values_to = "rescue_prob"
) %>%
mutate(
mutant = gsub("rescue_prob_", "", mutant),
s_value = case_when(
mutant %in% c("wd", "wb") ~ s_wm,
mutant %in% c("sd", "sb") ~ s_sm
)
)
# Plotting Rescue Probability with different s values
library(ggplot2)
ggplot(rescue_long, aes(x = factor(s_value), y = rescue_prob, fill = mutant)) +
geom_boxplot(alpha = 0.7) +
scale_y_continuous(limits = c(0, 1)) +
scale_fill_manual(values = c(
"wd" = "#77b5fe",
"wb" = "navyblue",
"sd" = "#D55E00",
"sb" = "darkred"
)) +
facet_wrap(~ mutant, scales = "free_x") +
labs(
title = "Rescue Probability per Mutant vs Relevant Selection Coefficient (Boxplot)",
x = "Relevant selection coefficient (s)",
y = "Rescue Probability",
fill = "Mutant"
) +
theme_minimal(base_size = 14)
ggplot(rescue_long, aes(x = s_value, y = rescue_prob, color = mutant)) +
geom_jitter(width = 0.01, height = 0, size = 3, alpha = 0.7) +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
scale_y_continuous(limits = c(0, 1)) +
scale_color_manual(values = c(
"wd" = "#77b5fe",
"wb" = "navyblue",
"sd" = "#D55E00",
"sb" = "darkred"
)) +
facet_wrap(~ mutant, scales = "free_x") +
labs(
title = "Rescue Probability per Mutant vs Relevant Selection Coefficient (Scatterplot)",
x = "Relevant selection coefficient (s)",
y = "Rescue Probability",
color = "Mutant"
) +
theme_minimal(base_size = 14)
# plotting wd with different s values
# making sure that its a data frame
data_table_wd <- as.data.frame(data_table_wd)
colnames(data_table_wd) <- c("V1", "V2")
# Scatterplot of wd with jitter and mean
library(ggplot2)
ggplot(data_table_wd, aes(x = factor(V1), y = V2, color = factor(V1))) +
geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
labs(
x = "selection coefficients",
y = "frequency",
color = "selection coefficient",
title = "Weak deleterious-Means of frequencies of the different selection coefficients"
) +
theme_minimal()
# plotting wb with different s values
# making sure that its a data frame
data_table_wb <- as.data.frame(data_table_wb)
colnames(data_table_sb) <- c("V1", "V2")
# Scatterplot of wb with jitter and mean
ggplot(data_table_wb, aes(x = factor(V1), y = V2, color = factor(V1))) +
geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
labs(
x = "selecton coefficients",
y = "frequency",
color = "selection coefficients",
title = "Weak beneficial-Means of frequencies of the different selection coefficientsn"
) +
theme_minimal()
# plotting sd with different s values
# making sure that its a data frame
data_table_sd <- as.data.frame(data_table_sd)
colnames(data_table_sd) <- c("V1", "V2")
# Scatterplot of sd with jitter and mean
ggplot(data_table_sd, aes(x = factor(V1), y = V2, color = factor(V1))) +
geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
labs(
x = "selection coefficients ",
y = "frequency",
color = "selection coefficients",
title = "Strong deletrious-Means of frequencies of the different selection coefficients"
) +
theme_minimal()
# plotting sb with different s values
# making sure that its a data frame
data_table_sb <- as.data.frame(data_table_sb)
colnames(data_table_sb) <- c("V1", "V2")
# Scatterplot of sb with jitter and mean
ggplot(data_table_sb, aes(x = factor(V1), y = V2, color = factor(V1))) +
geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
labs(
x = "selection coefficients",
y = "frequency",
color = "selection coefficients",
title = "Strong beneficial-Means of frequencies of the different selection coefficients"
) +
theme_minimal()
# mean Frequencies of each mutant
mean_freq_wd <- mean(freq_wd)*100
mean_freq_wb <- mean(freq_wb)*100
mean_freq_sd <- mean(freq_sd)*100
mean_freq_sb <- mean(freq_sb)*100
print(paste("Mean frequency of wd =", mean_freq_wd) )
print(paste("Mean frequency of wb =", mean_freq_wb) )
print(paste("Mean frequency of sd =", mean_freq_sd) )
print(paste("Mean frequency of sb =", mean_freq_sb) )
# define Column Names of Data Table
colnames(data_table) <- c("m_rate_wm","m_rate_sm","s_wm","s_sm","N_end_wd", "N_end_wb", "N_end_sd", "N_end_sb","freq_wd", "freq_wb", "freq_sd","freq_sb")
# show the first and last Lines of the Output
print(head(data_table))
print(tail(data_table))
#initial parameters set to certain values
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
no_replicates <- 50
#selection coefficients s and mutation rates m, varied (3 different values for both the weak and the strong strain)
s_values_wm <- c(0.10, 0.15, 0.20)
s_values_sm <- c(0.25, 0.30, 0.35)
m_values_wm <- c(0.004, 0.005, 0.006)
m_values_sm <- c(0.007, 0.008, 0.009)
#prepare empty data-tables to store results (one for each of the four mutations)
data_table <- c()
data_table_wd <- c()
data_table_wb <- c()
data_table_sd <- c()
data_table_sb <- c()
#----strong mutation----
#set up data frame to store the rescue results for the strong mutation, include selection coefficients and mutation rates of the strong mutation which should be stored as numeric values and the number of rescues for the strong beneficial and strong deleterious mutations (as whole numbers)
rescue_results <- data.frame(
s_sm = numeric(),
m_rate_sm = numeric(),
replicate = integer(),
rescued_sd = integer(),
rescued_sb = integer()
)
# creating for loops to vary through the three different values for the strong selection coefficients and the strong mutation rates and the number of replicates we need
for (mval_sm in m_values_sm) {
for (sval_sm in s_values_sm) {
for (rep in 1:no_replicates) {
# runing the simulation once (using the simulate_pop()function from before)
one_run <- simulate_pop(
init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_sm, s_wm, mval_sm, m_rate_wm, max_gen
)
# from the one_run, getting the final population-sizes of the strong deleterious and strong beneficial mutation
pop <- one_run$population
N_end_sd <- tail(pop[, "sd"], 1)
N_end_sb <- tail(pop[, "sb"], 1)
# saving the number of rescues, defined as the final population-size of the mutation being bigger than 0
rescued_sd <- as.integer(N_end_sd > 0)
rescued_sb <- as.integer(N_end_sb > 0)
# using the function r bind to combine all results into the data frame rescue_results which we set up before
rescue_results <- rbind(
rescue_results,
data.frame(
s_sm = sval_sm,
m_rate_sm = mval_sm,
replicate = rep,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
)
)
}
}
}
# creating a summary of the rescue results that we get of the strong mutations by taking the mean of the number of rescues over the replicates
library(dplyr)
rescue_summary <- rescue_results %>%
group_by(s_sm, m_rate_sm) %>%
summarise(
rescue_prob_sd = mean(rescued_sd),
rescue_prob_sb = mean(rescued_sb),
.groups = "drop"
)
#loading the needed packages "tidyr" and "ggplot2"
library(tidyr)
library(ggplot2)
# plotting the heatmaps for the strong mutations, using s-values for the x-axis, mutation rates for the y axis and the colouring indicating rescue-probabiltiy
ggplot(rescue_summary, aes(x = factor(s_sm), y = factor(m_rate_sm), fill = rescue_prob_sd)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),
limits = c(0, 1),
name = "Rescue Prob sd"
) +
labs(
title = "Heatmap: Rescue Probability of Strong Deleterious Mutation",
x = "Strong selection coefficients",
y = "Mutation rates (strong mutation)"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
)
ggplot(rescue_summary, aes(x = factor(s_sm), y = factor(m_rate_sm), fill = rescue_prob_sb)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),
limits = c(0, 1),
name = "Rescue Prob sb"
) +
labs(
title = "Heatmap: Rescue Probability of Strong Beneficial Mutation",
x = "Strong selection coefficients",
y = "Mutation rates (strong mutation)"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
)
#set up data frame to store the rescue results for the weak mutation, include selection coefficients and mutation rates of the weak mutation which should be stored as numeric values and the number of rescues for the weak beneficial and strong deleterious mutations (as whole numbers)
rescue_results <- data.frame(
s_wm = numeric(),
m_rate_wm = numeric(),
replicate = integer(),
rescued_wd = integer(),
rescued_wb = integer()
)
#creating for loops to vary through the three different values for the weak selection coefficients and the weak mutation rates and the number of replicates we need
for (mval_wm in m_values_wm) {
for (sval_wm in s_values_wm) {
for (rep in 1:no_replicates) {
#runing the simulation once (using the simulate_pop()function from before)
one_run <- simulate_pop(
init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, s_sm, mval_wm, m_rate_sm, max_gen
)
# from the one_run, getting the final population-sizes of the weak deleterious and strong beneficial mutation
pop <- one_run$population
N_end_wd <- tail(pop[, "wd"], 1)
N_end_wb <- tail(pop[, "wb"], 1)
#  saving the number of rescues, defined as the final population-size of the mutation being bigger than 0
rescued_wd <- as.integer(N_end_wd > 0)
rescued_wb <- as.integer(N_end_wb > 0)
# using the function r bind to combine all results into the data frame rescue_results which we set up before
rescue_results <- rbind(
rescue_results,
data.frame(
s_wm = sval_wm,
m_rate_wm = mval_wm,
replicate = rep,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb
)
)
}
}
}
# creating a summary of the rescue results that we get of the weak mutations by taking the mean of the number of rescues over the replicates
library(dplyr)
library(dplyr)
rescue_summary <- rescue_results %>%
group_by(s_wm, m_rate_wm) %>%
summarise(
rescue_prob_wd = mean(rescued_wd),
rescue_prob_wb = mean(rescued_wb),
.groups = "drop"
)
# loading needed packages "tidyr" and "ggplot2"
library(tidyr)
library(ggplot2)
# plotting the heatmaps for the weak mutations, using s-values for the x-axis, mutation rates for the y axis and the colouring indicating rescue-probabiltiy
ggplot(rescue_summary, aes(x = factor(s_wm), y = factor(m_rate_wm), fill = rescue_prob_wd)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.2, 1),
limits = c(0, 1),
name = "Rescue Prob wd"
) +
labs(
title = "Heatmap: Rescue Probability of Weak Deleterious Mutation",
x = "Weak selection coefficients",
y = "Mutation rates (weak mutation)"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
)
ggplot(rescue_summary, aes(x = factor(s_wm), y = factor(m_rate_wm), fill = rescue_prob_wb)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),
limits = c(0, 1),
name = "Rescue Prob wb"
) +
labs(
title = "Heatmap: Rescue Probability of Weak Beneficial Mutation",
x = "Weak selection coefficients",
y = "Mutation rates (weak mutation)"
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
)
# Plot first Line / first Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(end_gen, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot first Line / first Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(final_output, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
end_gen<-tail(which(!is.na(final_output[i,])), 1)
# each line gets assigned to a Color of lines_colors
lines(x=1:max_gen,y=final_output[i,1:max_gen], col=lines_colors[i])
}
