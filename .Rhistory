# set Parameters to vary
s_values_wm <- c(0.05,0.10,0.15)
s_values_sm <- c(0.2,0.25,0.30)
m_values_wm <- c(0.002,0.004,0.006)
m_values_sm <- c(0.006,0.008,0.010)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_sm = numeric(),
m_rate_sm = numeric(),
replicate = integer(),
rescued_sd = integer(),
rescued_sb = integer()
)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
for(mval_sm in m_values_sm){
for(sval_sm in s_values_sm){
for(rep in 1:no_replicates){
# Run your simulation
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_sm, s_wm, mval_sm, m_rate_wm, max_gen)
# Final population sizes for wm
N_end_sd <- one_run[nrow(one_run), "sd"]
N_end_sb <- one_run[nrow(one_run), "sb"]
# Determine rescue outcomes
rescued_sd <- as.integer(N_end_sd > 0)
rescued_sb <- as.integer(N_end_sb > 0)
# Append results
rescue_results <- rbind(rescue_results,
data.frame(
s_sm = sval_sm,
m_rate_sm = mval_sm,
replicate = rep,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
))
}
}
}
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
#m_rate_wm <- 0.001
#m_rate_sm <- 0.005
decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
s_values_sm <- c(0.2,0.25,0.30)
m_values_wm <- c(0.002,0.004,0.006)
m_values_sm <- c(0.006,0.008,0.010)
# initialize Data tables
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_wm = numeric(),
m_rate_wm = numeric(),
replicate = integer(),
rescued_wd = integer(),
rescued_wb = integer()
)
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
for(mval_wm in m_values_wm){
for(sval_wm in s_values_wm){
for(rep in 1:no_replicates){
# Run your simulation
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, s_sm, mval_wm, m_rate_sm, max_gen)
# Final population sizes for wm
N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
# Determine rescue outcomes
rescued_wd <- as.integer(N_end_wd > 0)
rescued_wb <- as.integer(N_end_wb > 0)
# Append results
rescue_results <- rbind(rescue_results,
data.frame(
s_wm = sval_wm,
m_rate_wm = mval_wm,
replicate = rep,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb
))
}
}
}
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
#m_rate_wm <- 0.001
#m_rate_sm <- 0.005
decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.05,0.10,0.15)
s_values_sm <- c(0.2,0.25,0.30)
m_values_wm <- c(0.002,0.004,0.006)
m_values_sm <- c(0.006,0.008,0.010)
# initialize Data tables
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_wm = numeric(),
m_rate_wm = numeric(),
replicate = integer(),
rescued_wd = integer(),
rescued_wb = integer()
)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
for(mval_wm in m_values_wm){
for(sval_wm in s_values_wm){
for(rep in 1:no_replicates){
# Run your simulation
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, s_sm, mval_wm, m_rate_sm, max_gen)
# Final population sizes for wm
N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
# Determine rescue outcomes
rescued_wd <- as.integer(N_end_wd > 0)
rescued_wb <- as.integer(N_end_wb > 0)
# Append results
rescue_results <- rbind(rescue_results,
data.frame(
s_wm = sval_wm,
m_rate_wm = mval_wm,
replicate = rep,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb
))
}
}
}
# Function for simulating one Generation in the Population
# adding the population sizes, decay rates, seleection coefficients and mutation rates
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw Offspring according to Poisson Distribution
# altered so all four different mutations are considered
# for deleterious mutations the s is calculated minus (negative effect) and for the beneficial muation the s is added (positive effect)
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw changing Mutants according to Poisson Distribution
# alterations considering the for different mutations
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new Population Sizes of all four Mutants (2 versions of weak Mutations   and 2   versions of strong Mutations)
# to account for back mutations as well (beneficial to deleterious), mutations rates for these cases are added (mut_b_to_d)
N_wd_new <- max(offsp_wd - mut_wd_to_wb+ mut_wb_to_wd,0)
N_wb_new <- max(offsp_wb - mut_wb_to_wd+ mut_wd_to_wb,0)
N_sd_new <- max(offsp_sd - mut_sd_to_sb+ mut_sb_to_sd,0)
N_sb_new <- max(offsp_sb - mut_sb_to_sd+ mut_sd_to_sb,0)
# with the return function, the new values for population sizes are stored
# Return new population sizes and mutation changes
return(list(
N_wd_new = N_wd_new,
N_wb_new = N_wb_new,
N_sd_new = N_sd_new,
N_sb_new = N_sb_new,
mut_wb_to_wd = mut_wb_to_wd,
mut_wd_to_wb = mut_wd_to_wb,
mut_sb_to_sd = mut_sb_to_sd,
mut_sd_to_sb = mut_sd_to_sb
))
}
# with print we visualize the numbers we get for the population sizes and mutation changes, we simulate the population by setting our parameters to certain values
print(simulate_one_gen(N_wd=50, N_wb=50, N_sd=50, N_sb=50, decay_rate_wm=0, decay_rate_sm=0, s_wm=0, s_sm=0, m_rate_wm=0.005, m_rate_sm=0.005))
# Simulation runs until the 100th Generation
max_gen=1000
#With this function we simulate over generations, we put initial population sizes of the four mutations, with the parameter max_gen we determine that our simulation maximally runs until the 100th geneeration
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the Vector in which to save the Results
pop_vector <- c(init_wd,init_wb, init_sd, init_sb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# defining counters for mutation changes
count_wb_to_wd <- 0
count_wd_to_wb <- 0
count_sb_to_sd <- 0
count_sd_to_sb <- 0
total_mut_events <- 0
# run the Simulation until Generation max_gen
for (i in 1:(max_gen + 1)) {
# redefine the current Population one Generation later
results <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new Population Sizes to the Output Vector
pop_new <- c(results$N_wd_new, results$N_wb_new, results$N_sd_new, results$N_sb_new)
pop_vector <- rbind(pop_vector,pop_new)
# count for tracking Mutations
count_wb_to_wd <- count_wb_to_wd + results$mut_wb_to_wd
count_wd_to_wb <- count_wd_to_wb + results$mut_wd_to_wb
count_sb_to_sd <- count_sb_to_sd + results$mut_sb_to_sd
count_sd_to_sb <- count_sd_to_sb + results$mut_sd_to_sb
total_mut_events <- total_mut_events + results$mut_wb_to_wd + results$mut_wd_to_wb +
results$mut_sb_to_sd + results$mut_sd_to_sb
# Condition to stop the Simulation before max_gen: either the Population exceeds 10 Times the Original Population Size, or it goes extinct
if ((sum(pop_new) >= 10 * sum(c(init_wd, init_wb, init_sd, init_sb))) || sum(pop_new) == 0)
break
}
# calculating Mutation Frequencies percent
if (total_mut_events > 0) {
freq_wb_to_wd <- 100 * count_wb_to_wd / total_mut_events
freq_wd_to_wb <- 100 * count_wd_to_wb / total_mut_events
freq_sb_to_sd <- 100 * count_sb_to_sd / total_mut_events
freq_sd_to_sb <- 100 * count_sd_to_sb / total_mut_events
} else {
freq_wb_to_wd <- freq_wd_to_wb <- freq_sb_to_sd <- freq_sd_to_sb <- 0
}
# Define the Row and Column Names of the Output Vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])]
# the colom-names in our vectors are according to our mutations (wd, wb, sd, sb)
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# Return mutation results
return(list(
population = pop_vector,
switch_stats = data.frame(
wb_to_wd = freq_wb_to_wd,
wd_to_wb = freq_wd_to_wb,
sb_to_sd = freq_sb_to_sd,
sd_to_sb = freq_sd_to_sb
)
))
}
# Test the Function and plot the Result
max_gen <- 100
# Simulation Data with certain values determined
output <- simulate_pop(init_wd=30, init_wb=30,  init_sd=30, init_sb=30, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.1, s_sm=0.2, m_rate_wm=0.003, m_rate_sm=0.005,max_gen)
# show the last few Lines of the Data Table
print(tail(output))
# extractin Population-Matrix
pop_matrix <- output$population
# assign frequencies of mutation changes
switch_stats <- output$switch_stats
print(switch_stats)
# determine x Axis Range
x_range <- 0:(nrow(pop_matrix)-1)
# plot the Output
# this plots the total Population Size-black line visible in the plot
plot(x_range, pop_matrix[,1] + pop_matrix[,2] + pop_matrix[,3] + pop_matrix[,4],
type='l', ylim=c(0,max(pop_matrix)), xlab="Generation", ylab="Population size",
col="black", lwd=1.5)
# adding each mutant
lines(x_range, pop_matrix[,1], col="#77b5fe", lwd=1.5) # wd
lines(x_range, pop_matrix[,2], col="navyblue", lwd=1.5) # wb
lines(x_range, pop_matrix[,3], col="#D55E00", lwd=1.5) # sd
lines(x_range, pop_matrix[,4], col="darkred", lwd=1.5) # sb
# Legend
legend("topleft",
legend=c("Total","wd","wb","sd","sb"),
col=c("black","#77b5fe","navyblue","#D55E00","darkred"),
lty=1, lwd=1.5)
# output of mutation changes in per cent
print(switch_stats)
# code for plotting the result of different populations in one plot
init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.002
m_rate_sm <- 0.003
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.1
s_sm <- 0.2
max_gen <- 1000
replicates <- 30
# defining Data Frame to save one Row (Population Size for multiple Generations until max_gen) after one Loop
temp_output <- data.frame(array(NA, dim = c(0,max_gen)))
# defining Data Frame to save all Results from Loop
final_output <- data.frame(array(NA, dim = c(replicates,max_gen)))
# defining a Set of colors in order to color each Line differently
lines_colors <- rainbow(replicates)
# simulating a population multiple times
for (i in 1:replicates) {
temp_output <- simulate_pop(
init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
s_wm, s_sm,
m_rate_wm, m_rate_sm,
max_gen = max_gen)
# extract Pop Matrix
pop_matrix <- temp_output$population
# calculate Row Sums
temp_output <- rowSums(pop_matrix[, c("wd", "wb", "sd", "sb")])
# adding to Result Table
final_output[i, 1:length(temp_output)]<-temp_output
}
# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot first Line / first Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(1500, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
end_gen<-tail(which(!is.na(final_output[i,])), 1)
# each line gets assigned to a Color of lines_colors
lines(x=1:max_gen,y=final_output[i,1:max_gen], col=lines_colors[i])
}
# same plot only that all lines of populations that go extinct, are colored grey
# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot one Line / one Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(1500, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
end_gen<-tail(which(!is.na(final_output[i,])), 1)
# if the length of end_gen is shorter than max_gen,then the Line will be colored grey
if (end_gen < max_gen){
line_col <- "grey"
# otherwise the line is colored randomly with another color
} else {
line_col <- lines_colors[i]
}
lines(x=1:max_gen,y=final_output[i,1:max_gen], col=line_col)
}
# set some Parameters to fixed Values
init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.01
m_rate_sm <- 0.01
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.2
s_sm <- 0.4
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.10,0.15,0.2)
s_values_sm <- c(0.25,0.30,0.35)
#m_values_wm <- c(0.001,0.01,0.05)
#m_values_sm <- c(0.05,0.1,0.15)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
rescued = integer()
)
# preparing list to save mutation changes (in per cent) for all replicates - only if they exist
switch_stats_all <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
wb_to_wd = numeric(),
wd_to_wb = numeric(),
sb_to_sd = numeric(),
sd_to_sb = numeric()
)
library(dplyr)
library(ggplot2)
library(tidyr)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
#for(mval_wm in m_values_wm){
# for(mval_sm in m_values_sm){
# loop over Selection strength
for(sval_wm in s_values_wm){
for(sval_sm in s_values_sm){
# different Way of running many Simulations: make Replicates using "repeat" Function         with a counter i
# reset Counter
i<-1
repeat {
# increase Counter by one
i<-i+1
# defining total runs
total_runs <- total_runs + 1
# run the Simulation once
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, sval_sm, m_rate_wm,m_rate_sm, max_gen)
# determine total Population Sizes
pop_matrix <- one_run$population
total_size <- rowSums(pop_matrix)
# Populationsextrakt
pop_matrix <- one_run$population
total_size <- rowSums(pop_matrix)
# saving mutation changes
if (!is.null(one_run$switch_stats) && nrow(one_run$switch_stats) > 0) {
switch_stats <- one_run$switch_stats
switch_stats_all <- rbind(
switch_stats_all,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i-1,
wb_to_wd = switch_stats$wb_to_wd,
wd_to_wb = switch_stats$wd_to_wb,
sb_to_sd = switch_stats$sb_to_sd,
sd_to_sb = switch_stats$sd_to_sb
)
)
}
# determine final Population Size for each Mutant
N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
N_end_sd <- pop_matrix[nrow(pop_matrix), "sd"]
N_end_sb <- pop_matrix[nrow(pop_matrix), "sb"]
total_end <- N_end_wd + N_end_wb + N_end_sd + N_end_sb
# introduce rescue count
rescued_wd <- ifelse(N_end_wd > 0, 1, 0)
rescued_wb <- ifelse(N_end_wb > 0, 1, 0)
rescued_sd <- ifelse(N_end_sd > 0, 1, 0)
rescued_sb <- ifelse(N_end_sb > 0, 1, 0)
# save rescue outcome (rescue or extinction)
rescue_results <- rbind(rescue_results,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i - 1,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
)
)
# determine Frequencies of each mutant in the final Population
freq_wd <- ifelse(total_end > 0, N_end_wd / total_end, 0)
freq_wb <- ifelse(total_end > 0, N_end_wb / total_end, 0)
freq_sd <- ifelse(total_end > 0, N_end_sd / total_end, 0)
freq_sb <- ifelse(total_end > 0, N_end_sb / total_end, 0)
data_table_wd<- rbind(data_table_wd, c(sval_wm,freq_wd))
data_table_wb<- rbind(data_table_wb, c(sval_wm, freq_wb))
data_table_sd<- rbind(data_table_sd,c(sval_sm, freq_sd))
data_table_sb<-rbind(data_table_sb, c (sval_sm,freq_sb))
# enter the Data into the Table
data_table <- rbind(data_table,c(m_rate_wm = 0.001,m_rate_sm = 0.005,sval_wm,sval_sm,N_end_wd,N_end_wb, N_end_sd, N_end_sb,freq_wd, freq_wb, freq_sd,freq_sb)) # note that we add the                varying parameters (mutation rate and selection strength for each version of weak            and strong mutation) to the table too
# stop the repeated Computation after no_replicates times
if(i>no_replicates) break
}
}
}
#}
#}
# Population over generations
print(one_run$population)
# Mutation changes in percent
print(switch_stats_all)
# Make sure data is a proper data frame
data_table_wd <- as.data.frame(data_table_wd)
# If the column names are missing or wrong, set them
colnames(data_table_wd) <- c("V1", "V2")
# Add an index column for plotting along x-axis
data_table_wd$Index <- 1:nrow(data_table_wd)
# plotting mutation changes with different s values
switch_long <- switch_stats_all %>%
pivot_longer(cols = c(wb_to_wd, wd_to_wb, sb_to_sd, sd_to_sb),
names_to = "switch_type",
values_to = "percent")
ggplot(switch_long, aes(x = factor(s_wm), y = percent, fill = switch_type)) +
geom_boxplot() +
facet_wrap(~ switch_type) +
labs(x = "s_wm", y = "Percentage of total mutation events") +
theme_minimal()
# calculate rescue probability per parameter combination
rescue_summary <- rescue_results %>%
group_by(s_wm, s_sm) %>%
summarise(
rescue_prob_wd = mean(rescued_wd),
rescue_prob_wb = mean(rescued_wb),
rescue_prob_sd = mean(rescued_sd),
rescue_prob_sb = mean(rescued_sb),
.groups = "drop"
)
