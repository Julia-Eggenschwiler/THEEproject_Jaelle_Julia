rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(50,50,0.1,0.4,0.2,0.5,0.5,0.5,max_gen)
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)+(offsp_wd + mut_wb_to_wd)
N_wb_new <- max(offsp_wb - mut_wb_to_wd, 0)+(offsp_wb + mut_wd_to_wb)
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)+(offsp_sd + mut_sb_to_sd)
N_sb_new <- max(offsp_sb - mut_sb_to_sd, 0)+(offsp_sb + mut_sd_to_sb)
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(N_wd=50, N_wb=0, N_sd=50, N_sb=0, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.2, s_sm=0.4, m_rate_wm=0.1, m_rate_sm=0.1))
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=50, init_wb=0,  init_sd=50, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.3, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=50, init_wb=0,  init_sd=50, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.3, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ 0,3]+output[ 0,4])),xlab =  "Generation",ylab = "Population size")
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)+(offsp_wd + mut_wb_to_wd)
N_wb_new <- max(offsp_wb - mut_wb_to_wd, 0)+(offsp_wb + mut_wd_to_wb)
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)+(offsp_sd + mut_sb_to_sd)
N_sb_new <- max(offsp_sb - mut_sb_to_sd, 0)+(offsp_sb + mut_sd_to_sb)
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(N_wd=50, N_wb=0, N_sd=50, N_sb=0, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.2, s_sm=0.4, m_rate_wm=0.1, m_rate_sm=0.1))
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)+(offsp_wd + mut_wb_to_wd)
N_wb_new <- max(offsp_wb - mut_wb_to_wd, 0)+(offsp_wb + mut_wd_to_wb)
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)+(offsp_sd + mut_sb_to_sd)
N_sb_new <- max(offsp_sb - mut_sb_to_sd, 0)+(offsp_sb + mut_sd_to_sb)
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(N_wd=50, N_wb=0, N_sd=50, N_sb=0, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.2, s_sm=0.4, m_rate_wm=0.1, m_rate_sm=0.1))
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)+(offsp_wd + mut_wb_to_wd)
N_wb_new <- max(offsp_wb - mut_wb_to_wd, 0)+(offsp_wb + mut_wd_to_wb)
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)+(offsp_sd + mut_sb_to_sd)
N_sb_new <- max(offsp_sb - mut_sb_to_sd, 0)+(offsp_sb + mut_sd_to_sb)
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(N_wd=50, N_wb=0, N_sd=50, N_sb=0, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.2, s_sm=0.4, m_rate_wm=0.1, m_rate_sm=0.1))
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# create your simulation data
output <- simulate_pop(init_wd=50, init_wb=0,  init_sd=50, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.3, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=50, init_wb=0,  init_sd=50, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.3, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[,3]+output[,4])),xlab =  "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[,3]+output[,4])),xlab =  "Generation",ylab = "Population size")
x_range
# show the last few lines of the data table
print(tail(output))
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)+(offsp_wd + mut_wb_to_wd)
N_wb_new <- max(offsp_wb - mut_wb_to_wd, 0)+(offsp_wb + mut_wd_to_wb)
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)+(offsp_sd + mut_sb_to_sd)
N_sb_new <- max(offsp_sb - mut_sb_to_sd, 0)+(offsp_sb + mut_sd_to_sb)
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(N_wd=50, N_wb=0, N_sd=50, N_sb=0, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.2, s_sm=0.4, m_rate_wm=0.1, m_rate_sm=0.1))
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="red")
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="red")
# add number of sd individuals
lines(x_range,output[,3], col="green")
# add number of sb individuals
lines(x_range,output[,4], col="orange")
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="navyblue")
# add number of sd individuals
lines(x_range,output[,3], col="red")
# add number of sb individuals
lines(x_range,output[,4], col="darkred")
legend("topright",
legend=c("Weak deleterious","Weak beneficial","Strong deleterious","Strong beneficial"),
col=c("blue","navyblue","red","darkred"), lty=1, lwd=1.5)
legend("topright", inset=c(-0.2,0),
legend=c("Weak deleterious","Weak beneficial","Strong deleterious","Strong beneficial"),
col=c("blue","navyblue","red","darkred"), lty=1, lwd=1.5)
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="navyblue")
# add number of sd individuals
lines(x_range,output[,3], col="red")
# add number of sb individuals
lines(x_range,output[,4], col="darkred")
legend("topright", inset=c(-0.2,0),
legend=c("Weak deleterious","Weak beneficial","Strong deleterious","Strong beneficial"),
col=c("blue","navyblue","red","darkred"), lty=1, lwd=1.5)
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="navyblue")
# add number of sd individuals
lines(x_range,output[,3], col="red")
# add number of sb individuals
lines(x_range,output[,4], col="darkred")
legend("topright", inset=c(3,0),
legend=c("Weak deleterious","Weak beneficial","Strong deleterious","Strong beneficial"),
col=c("blue","navyblue","red","darkred"), lty=1, lwd=1.5)
max_gen=1000
simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wd,init_wb, init_sd, init_wb)
# initiate the variables
pop_new <- c(init_wd, init_wb, init_sd, init_sb)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=5*(init_wd+init_wb+ init_sd+init_sb) |                          pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("wd","wb", "sd", "sb")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(init_wd=100, init_wb=0,  init_sd=100, init_sb=0, decay_rate_wm=0.2, decay_rate_sm=0.4, s_wm=0.1, s_sm=0.2, m_rate_wm=0.1, m_rate_sm=0.1,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2]+output[ ,3]+output[ ,4],type='l',ylim=c(0,max(output[,1]+output[,2]+output[ ,3]+output[ ,4])),xlab =  "Generation",ylab = "Population size")
# add number of wd individuals
lines(x_range,output[,1], col="blue")
# add number of wb individuals
lines(x_range,output[,2], col="navyblue")
# add number of sd individuals
lines(x_range,output[,3], col="red")
# add number of sb individuals
lines(x_range,output[,4], col="darkred")
legend("topleft",
legend=c("Weak deleterious","Weak beneficial","Strong deleterious","Strong beneficial"),
col=c("blue","navyblue","red","darkred"), lty=1, lwd=1.5)
