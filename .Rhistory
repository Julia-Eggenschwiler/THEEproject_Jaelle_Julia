<<<<<<< HEAD
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_wb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.6,0.2,0.6,0.01,0.01))
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.6,0.2,0.6,0.01,0.01))
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.6,0.2,0.6,0.1,0.1))
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.6,0.2,0.6,0.5,0.5))
=======
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, t_max) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_wm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, t_max) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_wm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.1,0.2,0.001,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:gen_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.1,0.2,0.001,max_gen)
# show the last few lines of the data table
print(tail(output))
simulate_one_gen <- function(N_a, N_A, decay_rate, sel_coeff, mut_rate) {
# draw offspring according to Poisson distribution
offsp_a <- rpois(1, N_a * (1-decay_rate))
offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
# draw new mutants according to Poisson distribution
mut_a_to_A <- rpois(1, offsp_a * mut_rate)
# determine new population sizes of wild type and mutant
N_a_new <- max(offsp_a - mut_a_to_A, 0)
N_A_new <-  offsp_A + mut_a_to_A
return(c(N_a_new, N_A_new))
}
# Test the function
print(simulate_one_gen(100,0,0.1,0.2,0.01))
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:gen_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.1,0.2,0.001,max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab =  "Generation",ylab = "Population size")
>>>>>>> fed07d347168d340090b86bbcc04ff5134ddf9d6
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.2,0.2,0.4,0.5,0.5))
<<<<<<< HEAD
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.4,0.2,0.5,0.5,0.5))
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.4,0.2,0.5,0.5,0.5))
simulate_one_gen <- function(N_wm, N_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
# draw offspring according to Poisson distribution
offsp_wd <- rpois(1, N_wm * (1-decay_rate_wm-s_wm))
offsp_wb <- rpois(1, N_wm * (1-decay_rate_wm+s_wm))
offsp_sd <- rpois(1, N_sm * (1-decay_rate_sm-s_sm))
offsp_sb <- rpois(1, N_sm * (1-decay_rate_sm+s_sm))
# draw new mutants according to Poisson distribution
mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
# determine new population sizes of wild type and mutant
N_wd_new <- max(offsp_wd - mut_wd_to_wb, 0)
N_wb_new <-  offsp_wb + mut_wd_to_wb
N_sd_new <- max(offsp_sd - mut_sd_to_sb, 0)
N_sb_new <-  offsp_sb + mut_sd_to_sb
return(c(N_wd_new, N_wb_new, N_sd_new, N_sb_new))
}
# Test the function
print(simulate_one_gen(50,50,0.1,0.4,0.2,0.5,0.5,0.5))
=======
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:gen_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.3,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.3,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,1000)
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.2,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.2,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.2,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1]+pop_new[2],pop_new[3]+pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(500,500,0.1,0.3,0.1,0.2,0.3,0.2,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1]+pop_new[2],pop_new[3]+pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(50,50,0.1,0.3,0.1,0.2,0.3,0.2,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, mut_rate_wm, mut_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1]+pop_new[2],pop_new[3]+pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(50,50,0.1,0.4,0.2,0.5,0.5,0.5,max_gen)
simulate_pop <- function(init_wm, init_sm, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
# Create the vector in which to save the results
pop_vector <- c(init_wm, init_sm)
# initiate the variables
pop_new <- c(init_wm, init_sm)
# run the simulation until generation t_max
for (i in 1:max_gen+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1]+pop_new[2],pop_new[3]+pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) | pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(50,50,0.1,0.4,0.2,0.5,0.5,0.5,max_gen)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]>=1.5*(init_wm+ init_sm) |                   pop_new[1]+pop_new[2]+pop_new[3]+pop_new[4]==0) break
>>>>>>> fed07d347168d340090b86bbcc04ff5134ddf9d6
