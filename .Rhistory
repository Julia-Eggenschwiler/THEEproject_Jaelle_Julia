}
library(dplyr)
rescue_summary <- rescue_results %>%
group_by(s_wm, m_rate_wm) %>%
summarise(
rescue_prob_wd = mean(rescued_wd),
rescue_prob_wb = mean(rescued_wb),
.groups = "drop"
)
library(tidyr)
library(ggplot2)
rescue_long <- rescue_summary %>%
pivot_longer(cols = starts_with("rescue_prob_"),
names_to = "mutant",
values_to = "rescue_prob") %>%
mutate(
mutant = gsub("rescue_prob_", "", mutant)
)
ggplot(rescue_summary, aes(x=factor(s_wm), y=factor(m_rate_wm), fill=rescue_prob_wd)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.2, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.4),
name = "Rescue Prob wd"
) +
labs(
title = "Heatmap rescue probability of weak deleterious mutation",
x = "weak selection coefficients",
y = "mutation rates weak mutation"
) +
theme_minimal()
ggplot(rescue_summary, aes(x=factor(s_wm), y=factor(m_rate_wm), fill=rescue_prob_wb)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.75),
name = "Rescue Prob wb"
) +
labs(
title = "Heatmap rescue probability of weak beneficial mutation",
x = "weak selection coefficients",
y = "mutation rates weak mutation"
) +
theme_minimal()
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
#m_rate_wm <- 0.001
#m_rate_sm <- 0.005
decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.05,0.10,0.15)
s_values_sm <- c(0.2,0.25,0.30)
m_values_wm <- c(0.002,0.004,0.006)
m_values_sm <- c(0.006,0.008,0.010)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_sm = numeric(),
m_rate_sm = numeric(),
replicate = integer(),
rescued_sd = integer(),
rescued_sb = integer()
)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
for(mval_sm in m_values_sm){
for(sval_sm in s_values_sm){
for(rep in 1:no_replicates){
# Run your simulation
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_sm, s_wm, mval_sm, m_rate_wm, max_gen)
# Final population sizes for wm
N_end_sd <- one_run[nrow(one_run), "sd"]
N_end_sb <- one_run[nrow(one_run), "sb"]
# Determine rescue outcomes
rescued_sd <- as.integer(N_end_sd > 0)
rescued_sb <- as.integer(N_end_sb > 0)
# Append results
rescue_results <- rbind(rescue_results,
data.frame(
s_sm = sval_sm,
m_rate_sm = mval_sm,
replicate = rep,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
))
}
}
}
library(dplyr)
library(dplyr)
rescue_summary <- rescue_results %>%
group_by(s_sm, m_rate_sm) %>%
summarise(
rescue_prob_sd = mean(rescued_sd),
rescue_prob_sb = mean(rescued_sb),
.groups = "drop"
)
library(tidyr)
library(ggplot2)
rescue_long <- rescue_summary %>%
pivot_longer(cols = starts_with("rescue_prob_"),
names_to = "mutant",
values_to = "rescue_prob") %>%
mutate(
mutant = gsub("rescue_prob_", "", mutant)
)
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sd)) +
geom_tile() +
scale_fill_gradientn(colors=c("blue","white","red"), name="Rescue Prob sd") +
labs(title="Heatmap rescue probability of strong deleterious mutation",
x="strong selection coefficients",
y="mutation rates strong mutation") +
theme_minimal()
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sd)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.06),
name = "Rescue Prob sd"
) +
labs(
title = "Heatmap rescue probability of strong deleterious mutation",
x = "strong selection-coefficients",
y = "mutation rates strong mutation"
) +
theme_minimal()
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sb)) +
geom_tile() +
scale_fill_gradientn(colors=c("blue","white","red"), name="Rescue Prob sb") +
labs(title="Heatmap rescue probability of strong beneficial mutation",
x="strong selection coefficients",
y="mutation rates strong mutation") +
theme_minimal()
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sb)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.8),
name = "Rescue Prob sb"
) +
labs(
title = "Heatmap rescue probability of strong beneficial mutation",
x = "strong selection coefficients",
y = "mutation rates strong mutation"
) +
theme_minimal()
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
#m_rate_wm <- 0.001
#m_rate_sm <- 0.005
decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.05,0.10,0.15)
s_values_sm <- c(0.2,0.25,0.30)
m_values_wm <- c(0.002,0.004,0.006)
m_values_sm <- c(0.006,0.008,0.010)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_sm = numeric(),
m_rate_sm = numeric(),
replicate = integer(),
rescued_sd = integer(),
rescued_sb = integer()
)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
for(mval_sm in m_values_sm){
for(sval_sm in s_values_sm){
for(rep in 1:no_replicates){
# Run your simulation
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_sm, s_wm, mval_sm, m_rate_wm, max_gen)
# Final population sizes for wm
N_end_sd <- one_run[nrow(one_run), "sd"]
N_end_sb <- one_run[nrow(one_run), "sb"]
# Determine rescue outcomes
rescued_sd <- as.integer(N_end_sd > 0)
rescued_sb <- as.integer(N_end_sb > 0)
# Append results
rescue_results <- rbind(rescue_results,
data.frame(
s_sm = sval_sm,
m_rate_sm = mval_sm,
replicate = rep,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
))
}
}
}
library(dplyr)
library(dplyr)
rescue_summary <- rescue_results %>%
group_by(s_sm, m_rate_sm) %>%
summarise(
rescue_prob_sd = mean(rescued_sd),
rescue_prob_sb = mean(rescued_sb),
.groups = "drop"
)
library(tidyr)
library(ggplot2)
rescue_long <- rescue_summary %>%
pivot_longer(cols = starts_with("rescue_prob_"),
names_to = "mutant",
values_to = "rescue_prob") %>%
mutate(
mutant = gsub("rescue_prob_", "", mutant)
)
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sd)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.06),
name = "Rescue Prob sd"
) +
labs(
title = "Heatmap rescue probability of strong deleterious mutation",
x = "strong selection-coefficients",
y = "mutation rates strong mutation"
) +
theme_minimal()
ggplot(rescue_summary, aes(x=factor(s_sm), y=factor(m_rate_sm), fill=rescue_prob_sb)) +
geom_tile() +
scale_fill_gradientn(
colors = c("blue", "#FFB3B3", "red"),
values = c(0, 0.3, 1),   # mehr Detail bei niedrigen Werten
limits = c(0, 0.8),
name = "Rescue Prob sb"
) +
labs(
title = "Heatmap rescue probability of strong beneficial mutation",
x = "strong selection coefficients",
y = "mutation rates strong mutation"
) +
theme_minimal()
library(ggplot2)
start_date <- as.Date("2025-09-03")
end_date <- as.Date("2025-11-06")
today <- Sys.Date()
total_days <- as.numeric(end_date - start_date) + 1
days_passed <- as.numeric(today - start_date) + 1
days_passed <- min(days_passed, total_days)
days_left <- total_days - days_passed
df <- data.frame(
status = c("vergangen", "verbleibend"),
value = c(days_passed, days_left)
)
ggplot(df, aes(x = 2, y = value, fill = status)) +
geom_bar(stat = "identity", width = 1, color = "black") +
coord_polar(theta = "y", start = -pi/2) +
xlim(0.5, 2.5) +
scale_fill_manual(values = c("vergangen" = "#8B0000", "verbleibend" = "#E0E0E0")) +
labs(
title = "Lionel is almost back :)",
subtitle = paste0(round((days_passed/total_days)*100,1), "% abgeschlossen, noch ", days_left, " Tage Ã¼brig")
) +
theme_void() +
theme(
plot.title = element_text(size = 22, face = "bold", hjust = 0.5, color = "#8B0000"),
plot.subtitle = element_text(size = 16, hjust = 0.5, color = "#4D0000"),
legend.position = "none"
)
# code for plotting the result of different populations in one plot
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
m_rate_wm <- 0.002 # approximately 0.4
m_rate_sm <- 0.003 # approximately 0.6
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.1
s_sm <- 0.2
max_gen <- 1000
replicates <- 30
# defining Data Frame to save one Row (Population Size for multiple Generations until max_gen) after one Loop
temp_output <- data.frame(array(NA, dim = c(0,max_gen)))
# defining Data Frame to save all Results from Loop
final_output <- data.frame(array(NA, dim = c(replicates,max_gen)))
# defining a Set of colors in order to color each Line differently
lines_colors <- rainbow(replicates)
# simulating a population multiple times
for (i in 1:replicates) {
temp_output <- simulate_pop(
init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
s_wm, s_sm,
m_rate_wm, m_rate_sm,
max_gen = max_gen)
# extract Pop Matrix
pop_matrix <- temp_output$population
# calculate Row Sums
temp_output <- rowSums(pop_matrix[, c("wd", "wb", "sd", "sb")])
# adding to Result Table
final_output[i, 1:length(temp_output)]<-temp_output
}
# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot one Line / one Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(1500, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
end_gen<-tail(which(!is.na(final_output[i,])), 1)
if (end_gen < max_gen){
line_col <- "grey"
} else {
line_col <- lines_colors[i]
}
lines(x=1:max_gen,y=final_output[i,1:max_gen], col=line_col)
}
# code for plotting the result of different populations in one plot
init_wd <- 30
# code for plotting the result of different populations in one plot
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50
m_rate_wm <- 0.002 # approximately 0.4
m_rate_sm <- 0.003 # approximately 0.6
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.1
s_sm <- 0.2
max_gen <- 1000
replicates <- 30
# defining Data Frame to save one Row (Population Size for multiple Generations until max_gen) after one Loop
temp_output <- data.frame(array(NA, dim = c(0,max_gen)))
# defining Data Frame to save all Results from Loop
final_output <- data.frame(array(NA, dim = c(replicates,max_gen)))
# defining a Set of colors in order to color each Line differently
lines_colors <- rainbow(replicates)
# simulating a population multiple times
for (i in 1:replicates) {
temp_output <- simulate_pop(
init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
s_wm, s_sm,
m_rate_wm, m_rate_sm,
max_gen = max_gen)
# extract Pop Matrix
pop_matrix <- temp_output$population
# calculate Row Sums
temp_output <- rowSums(pop_matrix[, c("wd", "wb", "sd", "sb")])
# adding to Result Table
final_output[i, 1:length(temp_output)]<-temp_output
}
# set some Parameters to fixed Values
init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.001
m_rate_sm <- 0.005
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.2
s_sm <- 0.3
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50
# set Parameters to vary
s_values_wm <- c(0.10,0.15,0.2)
s_values_sm <- c(0.25,0.30,0.35)
#m_values_wm <- c(0.001,0.01,0.05)
#m_values_sm <- c(0.05,0.1,0.15)
# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
rescued = integer()
)
# preparing list to save mutation changes (in per cent) for all replicates - only if they exist
switch_stats_all <- data.frame(
s_wm = numeric(),
s_sm = numeric(),
replicate = integer(),
wb_to_wd = numeric(),
wd_to_wb = numeric(),
sb_to_sd = numeric(),
sd_to_sb = numeric()
)
# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
#for(mval_wm in m_values_wm){
# for(mval_sm in m_values_sm){
# loop over Selection strength
for(sval_wm in s_values_wm){
for(sval_sm in s_values_sm){
# different Way of running many Simulations: make Replicates using "repeat" Function         with a counter i
# reset Counter
i<-1
repeat {
# increase Counter by one
i<-i+1
# defining total runs
total_runs <- total_runs + 1
# run the Simulation once
one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
decay_rate_wm, decay_rate_sm,
sval_wm, sval_sm, m_rate_wm=0.001,m_rate_sm=0.005, max_gen)
# determine total Population Sizes
pop_matrix <- one_run$population
total_size <- rowSums(pop_matrix)
# Populationsextrakt
pop_matrix <- one_run$population
total_size <- rowSums(pop_matrix)
# saving mutation changes
if (!is.null(one_run$switch_stats) && nrow(one_run$switch_stats) > 0) {
switch_stats <- one_run$switch_stats
switch_stats_all <- rbind(
switch_stats_all,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i-1,
wb_to_wd = switch_stats$wb_to_wd,
wd_to_wb = switch_stats$wd_to_wb,
sb_to_sd = switch_stats$sb_to_sd,
sd_to_sb = switch_stats$sd_to_sb
)
)
}
# determine final Population Size for each Mutant
N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
N_end_sd <- pop_matrix[nrow(pop_matrix), "sd"]
N_end_sb <- pop_matrix[nrow(pop_matrix), "sb"]
total_end <- N_end_wd + N_end_wb + N_end_sd + N_end_sb
# introduce rescue count
rescued_wd <- ifelse(N_end_wd > 0, 1, 0)
rescued_wb <- ifelse(N_end_wb > 0, 1, 0)
rescued_sd <- ifelse(N_end_sd > 0, 1, 0)
rescued_sb <- ifelse(N_end_sb > 0, 1, 0)
# save rescue outcome (rescue or extinction)
rescue_results <- rbind(rescue_results,
data.frame(
s_wm = sval_wm,
s_sm = sval_sm,
replicate = i - 1,
rescued_wd = rescued_wd,
rescued_wb = rescued_wb,
rescued_sd = rescued_sd,
rescued_sb = rescued_sb
)
)
# determine Frequencies of each mutant in the final Population
freq_wd <- ifelse(total_end > 0, N_end_wd / total_end, 0)
freq_wb <- ifelse(total_end > 0, N_end_wb / total_end, 0)
freq_sd <- ifelse(total_end > 0, N_end_sd / total_end, 0)
freq_sb <- ifelse(total_end > 0, N_end_sb / total_end, 0)
data_table_wd<- rbind(data_table_wd, c(sval_wm,freq_wd))
data_table_wb<- rbind(data_table_wb, c(sval_wm, freq_wb))
data_table_sd<- rbind(data_table_sd,c(sval_sm, freq_sd))
data_table_sb<-rbind(data_table_sb, c (sval_sm,freq_sb))
# enter the Data into the Table
data_table <- rbind(data_table,c(m_rate_wm = 0.001,m_rate_sm = 0.005,sval_wm,sval_sm,N_end_wd,N_end_wb, N_end_sd, N_end_sb,freq_wd, freq_wb, freq_sd,freq_sb)) # note that we add the                varying parameters (mutation rate and selection strength for each version of weak            and strong mutation) to the table too
# stop the repeated Computation after no_replicates times
if(i>no_replicates) break
}
}
}
