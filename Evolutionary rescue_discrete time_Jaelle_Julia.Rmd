---
title: "A computational model for antibiotic resistance"
author: "Jaelle HÃ¤fliger and Julia Eggenschwiler"
date: "2025-11-06"
output:
  html_document:
    df_print: paged
---

------------------------------------------------------------------------

## Simulating evolutionary rescue in discrete time

In this notebook, we are implementing simulations of evolutionary rescue with 4 different mutations of different strengths in discrete time, as discussed and analyzed in the work by Orr & Unckless. The model is as follows: a haploid population starts with a given number of weak deleterious mutants, weak beneficial mutants, strong deleterious mutants and strong beneficial mutants. We define the two weak mutants as the weak strain and the two strong mutants as strong strain. The model allows for mutation within one strain from deleterious to beneficial mutants, but also from beneficial to deleterious mutants (back-mutation). We want to determine the trade-off of either starting only as weak deleterious and mutating to only weak beneficial or starting strong deleterious but being able to mutate to strong beneficial. To this scenario the back-mutation acts as an additional source of complexity. Each mutant is  considered rescued if the population-size of the mutant stays bigger than 0 after max_gen (100 generations). 

## List of variables and parameters

-   **N_end_wd:** size of the mutant (wd) population

-   **N_end_wb:** size of the mutant (wb) population

-   **N_end_sd:** size of the mutant (sd) population

-   **N_end_sb:** size of the mutant (sb) population

-   **init_wd:** initial population size of population with the weak deleterious mutation (should be a positive integer)

-   **init_wb:** initial population size of the population with the weak beneficial mutation (should be a non-negative

-   **init_sd:** initial population size of the population with the strong deleterious mutation (should be a positive integer)

-   **init_sb:** initial population size of the population with the strong beneficial mutation (should be a non-negative integer)

-   **decay_rate_wm:** detrimental effect of the environment on the weak mutation (i.e., the populations carrying weak mutations decays at this rate; should be \>0 to induce potential extinction)

-   **decay_rate_sm:** detrimental effect of the environment on the strong mutation (i.e., the populations carrying strong mutations decays at this rate; should be \>0 to induce potential extinction)

-   **s_wm:** selective strength of the weak mutation (should be \>decay_rate to allow for evolutionary rescue)

-   **s_sm:** selective strength of the strong mutation (should be \>decay_rate to allow for evolutionary rescue)

-   **m_rate_wm:** mutation rate from the weak deletrious to the weak beneficial deleterious mutation and from weak beneficial to weak deleterious mutation (should be \>0 and small)

    **m_rate_sm:** mutation rate from the strong deleterious to the strong beneficial mutation and from strong beneficial to strong deleterious mutation (should be \>0 and small)

-   **max_gen:** number of generations after which to stop the simulation (should be an integer \>0; this is not a model parameter but a setting for the simulations). In the code presented here, the simulation stops automatically if the population goes extinct, or if it recovers and exceeds 10 times the original total population size, so **max_gen** can be set to a large value without creating extremely long simulation times.

## Our Question

How do 2 deleterious mutations of different strength , which can mutate to beneficial ones, influence the probability of rescue and how does their frequency in the population change?
How do 2 mutations, which can alternate between beneficial and deleterious versions of the same strength, influence the probability of rescue and how does their frequency in the population change?

## Definitions

-   wd: weak deleterious
-   wb: weak beneficial
-   sd: strong deleterious
-   sb: strong beneficial

```{r}
# Function for simulating one Generation in the Population
# adding the population sizes, decay rates, seleection coefficients and mutation rates
simulate_one_gen <- function(N_wd, N_wb, N_sd, N_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm) {
  
  # draw Offspring according to Poisson Distribution
  # altered so all four different mutations are considered 
  # for deleterious mutations the s is calculated minus (negative effect) and for the beneficial muation the s is added (positive effect)
  
  offsp_wd <- rpois(1, N_wd * (1-decay_rate_wm-s_wm))
  offsp_wb <- rpois(1, N_wb * (1-decay_rate_wm+s_wm))
  offsp_sd <- rpois(1, N_sd * (1-decay_rate_sm-s_sm))
  offsp_sb <- rpois(1, N_sb * (1-decay_rate_sm+s_sm))
  
  # draw changing Mutants according to Poisson Distribution
  # alterations considering the for different mutations 
  
  mut_wd_to_wb <- rpois(1, offsp_wd * m_rate_wm)
  mut_sd_to_sb <- rpois(1, offsp_sd * m_rate_sm)
  mut_wb_to_wd <- rpois(1, offsp_wb * m_rate_wm)
  mut_sb_to_sd <- rpois(1, offsp_sb * m_rate_sm)
  
  # determine new Population Sizes of all four Mutants (2 versions of weak Mutations   and 2   versions of strong Mutations)
  # to account for back mutations as well (beneficial to deleterious), mutations rates for these cases are added (mut_b_to_d)
  
  N_wd_new <- max(offsp_wd - mut_wd_to_wb+ mut_wb_to_wd,0)
  N_wb_new <- max(offsp_wb - mut_wb_to_wd+ mut_wd_to_wb,0)
  N_sd_new <- max(offsp_sd - mut_sd_to_sb+ mut_sb_to_sd,0)
  N_sb_new <- max(offsp_sb - mut_sb_to_sd+ mut_sd_to_sb,0)
  
  # with the return function, the new values for population sizes are stored
  
   # Return new population sizes and mutation changes
  return(list(
    N_wd_new = N_wd_new,
    N_wb_new = N_wb_new,
    N_sd_new = N_sd_new,
    N_sb_new = N_sb_new,
    mut_wb_to_wd = mut_wb_to_wd,
    mut_wd_to_wb = mut_wd_to_wb,
    mut_sb_to_sd = mut_sb_to_sd,
    mut_sd_to_sb = mut_sd_to_sb
  ))
}
  # with print we visualize the numbers we get for the population sizes and mutation changes, we simulate the population by setting our parameters to certain values 


print(simulate_one_gen(N_wd=50, N_wb=50, N_sd=50, N_sb=50, decay_rate_wm=0.2, decay_rate_sm=0.2, s_wm=0.1, s_sm=0.2, m_rate_wm=0.002, m_rate_sm=0.003))
```

## Simulate a population trajectory

We can now track the dynamics of the population from one generation to another, but this is not enough. We want to follow the population from time 0 until it either is rescued or goes extinct. This is what the following function does.

```{r}
# Simulation runs until the 100th Generation

max_gen=1000

#With this function we simulate over generations, we put initial population sizes of the four mutations, with the parameter max_gen we determine that our simulation maximally runs until the 100th geneeration

simulate_pop <- function(init_wd, init_wb,  init_sd, init_sb, decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm, max_gen) {
  
  # Create the Vector in which to save the Results
  pop_vector <- c(init_wd,init_wb, init_sd, init_sb)
  
  # initiate the variables
  pop_new <- c(init_wd, init_wb, init_sd, init_sb)
  
  # defining counters for mutation changes
  count_wb_to_wd <- 0
  count_wd_to_wb <- 0
  count_sb_to_sd <- 0
  count_sd_to_sb <- 0
  total_mut_events <- 0
  
  # run the Simulation until Generation max_gen
  for (i in 1:(max_gen + 1)) {
    
    # redefine the current Population one Generation later
    results <- simulate_one_gen(pop_new[1],pop_new[2],pop_new[3],pop_new[4], decay_rate_wm, decay_rate_sm, s_wm, s_sm, m_rate_wm, m_rate_sm)
    
    # add the new Population Sizes to the Output Vector
    pop_new <- c(results$N_wd_new, results$N_wb_new, results$N_sd_new, results$N_sb_new)
    pop_vector <- rbind(pop_vector,pop_new)
    
     # count for tracking Mutations
    count_wb_to_wd <- count_wb_to_wd + results$mut_wb_to_wd
    count_wd_to_wb <- count_wd_to_wb + results$mut_wd_to_wb
    count_sb_to_sd <- count_sb_to_sd + results$mut_sb_to_sd
    count_sd_to_sb <- count_sd_to_sb + results$mut_sd_to_sb
    total_mut_events <- total_mut_events + results$mut_wb_to_wd + results$mut_wd_to_wb +
      results$mut_sb_to_sd + results$mut_sd_to_sb
      
    # Condition to stop the Simulation before max_gen: either the Population exceeds 10 Times the Original Population Size, or it goes extinct
    
    if ((sum(pop_new) >= 10 * sum(c(init_wd, init_wb, init_sd, init_sb))) || sum(pop_new) == 0)
      break

}
    # calculating Mutation Frequencies percent
    if (total_mut_events > 0) {
    freq_wb_to_wd <- 100 * count_wb_to_wd / total_mut_events
    freq_wd_to_wb <- 100 * count_wd_to_wb / total_mut_events
    freq_sb_to_sd <- 100 * count_sb_to_sd / total_mut_events
    freq_sd_to_sb <- 100 * count_sd_to_sb / total_mut_events
  } else {
    freq_wb_to_wd <- freq_wd_to_wb <- freq_sb_to_sd <- freq_sd_to_sb <- 0
  }  
  # Define the Row and Column Names of the Output Vector
  rownames(pop_vector) <- (0:max_gen)[1:length(pop_vector[,1])] 
  
  # the colom-names in our vectors are according to our mutations (wd, wb, sd, sb)
  
  colnames(pop_vector) <- c("wd","wb", "sd", "sb")
  
    
  
  # Return mutation results
  return(list(
    population = pop_vector,
    switch_stats = data.frame(
      wb_to_wd = freq_wb_to_wd,
      wd_to_wb = freq_wd_to_wb,
      sb_to_sd = freq_sb_to_sd,
      sd_to_sb = freq_sd_to_sb
    )
  ))
}
  



# Test the Function and plot the Result

max_gen <- 100

# Simulation Data with certain values determined

output <- simulate_pop(init_wd=30, init_wb=30,  init_sd=30, init_sb=30, decay_rate_wm=0.1, decay_rate_sm=0.2, s_wm=0.1, s_sm=0.2, m_rate_wm=0.003, m_rate_sm=0.005,max_gen)

# show the last few Lines of the Data Table

print(tail(output))

# extracting Population-Matrix 
pop_matrix <- output$population

# assign frequencies of mutation changes
switch_stats <- output$switch_stats


# determine x Axis Range 
x_range <- 0:(nrow(pop_matrix)-1)

# plot the Output
# this plots the total Population Size-black line visible in the plot
plot(x_range, pop_matrix[,1] + pop_matrix[,2] + pop_matrix[,3] + pop_matrix[,4],
     type='l', ylim=c(0,max(pop_matrix)), xlab="Generation", ylab="Population size",
     col="black", lwd=1.5)

# adding each mutant
lines(x_range, pop_matrix[,1], col="#77b5fe", lwd=1.5) # wd
lines(x_range, pop_matrix[,2], col="navyblue", lwd=1.5) # wb
lines(x_range, pop_matrix[,3], col="#D55E00", lwd=1.5) # sd
lines(x_range, pop_matrix[,4], col="darkred", lwd=1.5) # sb

# Legend
legend("topleft",
       legend=c("Total","wd","wb","sd","sb"),
       col=c("black","#77b5fe","navyblue","#D55E00","darkred"),
       lty=1, lwd=1.5)

# output of mutation changes in per cent
print(switch_stats)

```











Plot showing the outcome (rescue or extinction) of various population
```{r}
# code for plotting the result of different populations in one plot
init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.003 
m_rate_sm <- 0.005
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.1
s_sm <- 0.2
max_gen <- 1000
replicates <- 30


# defining Data Frame to save one Row (Population Size for multiple Generations until max_gen) after one Loop
temp_output <- data.frame(array(NA, dim = c(0,max_gen)))
# defining Data Frame to save all Results from Loop
final_output <- data.frame(array(NA, dim = c(replicates,max_gen)))
# defining a Set of colors in order to color each Line differently
lines_colors <- rainbow(replicates)

# simulating a population multiple times
for (i in 1:replicates) {
  temp_output <- simulate_pop(
    init_wd, init_wb, init_sd, init_sb,
    decay_rate_wm, decay_rate_sm,
    s_wm, s_sm,
    m_rate_wm, m_rate_sm,
    max_gen = max_gen)
  # extract Pop Matrix
  pop_matrix <- temp_output$population
  
  # calculate Row Sums
  temp_output <- rowSums(pop_matrix[, c("wd", "wb", "sd", "sb")])
  # adding to Result Table
  final_output[i, 1:length(temp_output)]<-temp_output
}

# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot first Line / first Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(1500, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
  
  end_gen<-tail(which(!is.na(final_output[i,])), 1)
  # each line gets assigned to a Color of lines_colors
  lines(x=1:max_gen,y=final_output[i,1:max_gen], col=lines_colors[i])
  
  
}

# same plot only that all lines of populations that go extinct, are colored grey
# defining end_gen which is as long as the last Generation where the pop size is an actual Number and not NA yet
end_gen<-tail(which(!is.na(final_output[1,])), 1)
# Plot one Line / one Population
plot(x=1:max_gen,y=final_output[1,1:max_gen],type='l',ylim=c(0,max(1500, na.rm = TRUE)),xlab =  "Generation",ylab = "Population size", col = lines_colors[1])
# Loop for plotting each Row of Data Table / Population as a Line in the Plot
for (i in 1:replicates) {
  
  end_gen<-tail(which(!is.na(final_output[i,])), 1)
  # if the length of end_gen is shorter than max_gen,then the Line will be colored grey
  if (end_gen < max_gen){
    line_col <- "grey"
    # otherwise the line is colored randomly with another color
  } else {
    line_col <- lines_colors[i]
  }
  lines(x=1:max_gen,y=final_output[i,1:max_gen], col=line_col)
  
  
}

```
## A small analysis

As you can see if you simulate and plot the output several times, there is a lot of stochasticity/variation in the outcome. Therefore, to get interpretable results, we have to run the simulation many times and summarize the outcome depending on the question of our study. Here I am showing an example in which we record the time and the value of the lowest population size (or the time of extinction, if the population size eventually goes to 0). Usually, we want to study this for a range of model parameters; here I am varying the decay rate and the selection coefficient. Other (maybe more interesting) features to study would be the following: =\>simulating varying parameters with replicates per one value

-   rescue probability dependent on initial frequency and selection coefficient
-   time at which the rescue mutation occurs first if it rescues, vs. if it doesn't rescue, dependent on initial population size and mutation rate
-   time until the population has recovered in case it becomes rescued, dependent on mutation rate and selection coefficient
-   ...

```{r}
# set some Parameters to fixed Values

init_wd <- 30
init_wb <- 30
init_sd <- 30
init_sb <- 30
m_rate_wm <- 0.01
m_rate_sm <- 0.01
decay_rate_wm <- 0.1
decay_rate_sm <- 0.2
s_wm <- 0.05
s_sm <- 0.1
max_gen <- 1000
# determine how often to run the Simulation for each set of Parameters
no_replicates <- 50


# set Parameters to vary
s_values_wm <- c(0.10,0.15,0.2)
s_values_sm <- c(0.25,0.30,0.35)
#Commented to vary always only one variable
#m_values_wm <- c(0.001,0.01,0.05)
#m_values_sm <- c(0.05,0.1,0.15)


# initialize Data Table - where to collect the Results
data_table <- c()
data_table_wd<- c()
data_table_wb<- c()
data_table_sd<- c()
data_table_sb<- c()
# empty list to save rescue results
rescue_results <- data.frame(
  s_wm = numeric(),
  s_sm = numeric(),
  replicate = integer(),
  rescued = integer()
)

# preparing list to save mutation changes (in per cent) for all replicates - only if they exist
switch_stats_all <- data.frame(
  s_wm = numeric(),
  s_sm = numeric(),
  replicate = integer(),
  wb_to_wd = numeric(),
  wd_to_wb = numeric(),
  sb_to_sd = numeric(),
  sd_to_sb = numeric()
)

library(dplyr)
library(ggplot2)
library(tidyr)

# define total runs and rescue count
total_runs<-0
rescue_count<-0
# run the Simulation across all chosen parameters
# loop over mutation rates
#for(mval_wm in m_values_wm){
 # for(mval_sm in m_values_sm){
    # loop over Selection strength
    for(sval_wm in s_values_wm){
      for(sval_sm in s_values_sm){
        # different Way of running many Simulations: make Replicates using "repeat" Function         with a counter i
        # reset Counter
        i<-1
        
        repeat {
          # increase Counter by one
          i<-i+1
          # defining total runs
          total_runs <- total_runs + 1
          # run the Simulation once
          one_run <- simulate_pop(init_wd, init_wb, init_sd, init_sb,
                                  decay_rate_wm, decay_rate_sm,
                                  sval_wm, sval_sm, m_rate_wm,m_rate_sm, max_gen)
          
          # determine total Population Sizes
         pop_matrix <- one_run$population


         total_size <- rowSums(pop_matrix)
          
  # defining popuation matrix
  pop_matrix <- one_run$population
  # calculating total size (1 row is equal to total pop size, meaning adding up all columns)
  total_size <- rowSums(pop_matrix)
# saving mutation changes  
 if (!is.null(one_run$switch_stats) && nrow(one_run$switch_stats) > 0) {
  switch_stats <- one_run$switch_stats
  switch_stats_all <- rbind(
    switch_stats_all,
    data.frame(
      s_wm = sval_wm,
      s_sm = sval_sm,
      replicate = i-1,
      wb_to_wd = switch_stats$wb_to_wd,
      wd_to_wb = switch_stats$wd_to_wb,
      sb_to_sd = switch_stats$sb_to_sd,
      sd_to_sb = switch_stats$sd_to_sb
    )
  )
}
          
          
          # determine final Population Size for each Mutant
          N_end_wd <- pop_matrix[nrow(pop_matrix), "wd"]
          N_end_wb <- pop_matrix[nrow(pop_matrix), "wb"]
          N_end_sd <- pop_matrix[nrow(pop_matrix), "sd"]
          N_end_sb <- pop_matrix[nrow(pop_matrix), "sb"]
        
          total_end <- N_end_wd + N_end_wb + N_end_sd + N_end_sb
          # introduce rescue count
         rescued_wd <- ifelse(N_end_wd > 0, 1, 0)
         rescued_wb <- ifelse(N_end_wb > 0, 1, 0)
         rescued_sd <- ifelse(N_end_sd > 0, 1, 0)
         rescued_sb <- ifelse(N_end_sb > 0, 1, 0)

         
          # save rescue outcome (rescue or extinction)
          rescue_results <- rbind(rescue_results,
            data.frame(
              s_wm = sval_wm,
              s_sm = sval_sm,
              replicate = i - 1,
              rescued_wd = rescued_wd,
              rescued_wb = rescued_wb,
              rescued_sd = rescued_sd,
              rescued_sb = rescued_sb
  )
)

          # determine Frequencies of each mutant in the final Population
          freq_wd <- ifelse(total_end > 0, N_end_wd / total_end, 0)
          freq_wb <- ifelse(total_end > 0, N_end_wb / total_end, 0)
          freq_sd <- ifelse(total_end > 0, N_end_sd / total_end, 0)
          freq_sb <- ifelse(total_end > 0, N_end_sb / total_end, 0)
          
          
          
          data_table_wd<- rbind(data_table_wd, c(sval_wm,freq_wd))
          data_table_wb<- rbind(data_table_wb, c(sval_wm, freq_wb))
          data_table_sd<- rbind(data_table_sd,c(sval_sm, freq_sd))
          data_table_sb<-rbind(data_table_sb, c (sval_sm,freq_sb))
          # enter the Data into the Table
          data_table <- rbind(data_table,c(m_rate_wm = 0.001,m_rate_sm = 0.005,sval_wm,sval_sm,N_end_wd,N_end_wb, N_end_sd, N_end_sb,freq_wd, freq_wb, freq_sd,freq_sb)) # note that we add the varying Parameters (Mutation Rate and Selection Strength for each Version of weak and strong Mutation) to the Table too
          # stop the repeated Computation after no_replicates times
          
          
          if(i>no_replicates) break
          
        }
      }
    }
  #}
#}

# Population over generations
print(one_run$population)
# Mutation changes in percent
print(switch_stats_all)



# Make sure data is a proper data frame
data_table_wd <- as.data.frame(data_table_wd)

# If the column names are missing or wrong, set them
colnames(data_table_wd) <- c("V1", "V2")

# Add an Index Column for plotting along x-axis
data_table_wd$Index <- 1:nrow(data_table_wd)

# plotting Mutation Changes with different s values
switch_long <- switch_stats_all %>%
  pivot_longer(cols = c(wb_to_wd, wd_to_wb, sb_to_sd, sd_to_sb),
               names_to = "switch_type",
               values_to = "percent")

ggplot(switch_long, aes(x = factor(s_wm), y = percent, fill = switch_type)) +
  geom_boxplot() +
  facet_wrap(~ switch_type) +
  labs(x = "s_wm", y = "Percentage of total mutation events") +
  theme_minimal()

# calculate Rescue Probability per Parameter Combination

rescue_summary <- rescue_results %>%
  group_by(s_wm, s_sm) %>%
  summarise(
    rescue_prob_wd = mean(rescued_wd),
    rescue_prob_wb = mean(rescued_wb),
    rescue_prob_sd = mean(rescued_sd),
    rescue_prob_sb = mean(rescued_sb),
    .groups = "drop"
  )

print(rescue_summary)


# Prepare rescue data
rescue_long <- rescue_summary %>%
  pivot_longer(
    cols = starts_with("rescue_prob_"),
    names_to = "mutant",
    values_to = "rescue_prob"
  ) %>%
  mutate(
    mutant = gsub("rescue_prob_", "", mutant),
    s_value = case_when(
      mutant %in% c("wd", "wb") ~ s_wm,
      mutant %in% c("sd", "sb") ~ s_sm
    )
  )

# Plotting Rescue Probability with different s values
library(ggplot2)

ggplot(rescue_long, aes(x = factor(s_value), y = rescue_prob, fill = mutant)) +
  geom_boxplot(alpha = 0.7) +
  scale_y_continuous(limits = c(0, 1)) +
  scale_fill_manual(values = c(
    "wd" = "#77b5fe", 
    "wb" = "navyblue", 
    "sd" = "#D55E00", 
    "sb" = "darkred"
  )) +
  facet_wrap(~ mutant, scales = "free_x") +
  labs(
    title = "Rescue Probability per Mutant vs Relevant Selection Coefficient (Boxplot)",
    x = "Relevant selection coefficient (s)",
    y = "Rescue Probability",
    fill = "Mutant"
  ) +
  theme_minimal(base_size = 14)

ggplot(rescue_long, aes(x = s_value, y = rescue_prob, color = mutant)) +
  geom_jitter(width = 0.01, height = 0, size = 3, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  scale_y_continuous(limits = c(0, 1)) +
  scale_color_manual(values = c(
    "wd" = "#77b5fe", 
    "wb" = "navyblue", 
    "sd" = "#D55E00", 
    "sb" = "darkred"
  )) +
  facet_wrap(~ mutant, scales = "free_x") +
  labs(
    title = "Rescue Probability per Mutant vs Relevant Selection Coefficient (Scatterplot)",
    x = "Relevant selection coefficient (s)",
    y = "Rescue Probability",
    color = "Mutant"
  ) +
  theme_minimal(base_size = 14)














# plotting wd with different s values
  # making sure that its a data frame
data_table_wd <- as.data.frame(data_table_wd)
colnames(data_table_wd) <- c("V1", "V2")


  # Scatterplot of wd with jitter and mean 
library(ggplot2)
ggplot(data_table_wd, aes(x = factor(V1), y = V2, color = factor(V1))) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  labs(
    x = "selection coefficients",
    y = "frequency",
    color = "selection coefficient",
    title = "Weak deleterious-Means of frequencies of the different selection coefficients"
  ) +
  theme_minimal()

# plotting wb with different s values
  # making sure that its a data frame
data_table_wb <- as.data.frame(data_table_wb)
colnames(data_table_sb) <- c("V1", "V2")

# Scatterplot of wb with jitter and mean
ggplot(data_table_wb, aes(x = factor(V1), y = V2, color = factor(V1))) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  labs(
    x = "selecton coefficients",
    y = "frequency",
    color = "selection coefficients",
    title = "Weak beneficial-Means of frequencies of the different selection coefficientsn"
  ) +
  theme_minimal()

# plotting sd with different s values
  # making sure that its a data frame
data_table_sd <- as.data.frame(data_table_sd)

colnames(data_table_sd) <- c("V1", "V2")

  # Scatterplot of sd with jitter and mean
ggplot(data_table_sd, aes(x = factor(V1), y = V2, color = factor(V1))) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  labs(
    x = "selection coefficients ",
    y = "frequency",
    color = "selection coefficients",
    title = "Strong deletrious-Means of frequencies of the different selection coefficients"
  ) +
  theme_minimal()

# plotting sb with different s values
  # making sure that its a data frame
data_table_sb <- as.data.frame(data_table_sb)
colnames(data_table_sb) <- c("V1", "V2")

  # Scatterplot of sb with jitter and mean 
ggplot(data_table_sb, aes(x = factor(V1), y = V2, color = factor(V1))) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  labs(
    x = "selection coefficients",
    y = "frequency",
    color = "selection coefficients",
    title = "Strong beneficial-Means of frequencies of the different selection coefficients"
  ) +
  theme_minimal()


# mean Frequencies of each mutant
mean_freq_wd <- mean(freq_wd)*100
mean_freq_wb <- mean(freq_wb)*100
mean_freq_sd <- mean(freq_sd)*100
mean_freq_sb <- mean(freq_sb)*100

print(paste("Mean frequency of wd =", mean_freq_wd) )
print(paste("Mean frequency of wb =", mean_freq_wb) )
print(paste("Mean frequency of sd =", mean_freq_sd) )
print(paste("Mean frequency of sb =", mean_freq_sb) )

# define Column Names of Data Table
colnames(data_table) <- c("m_rate_wm","m_rate_sm","s_wm","s_sm","N_end_wd", "N_end_wb", "N_end_sd", "N_end_sb","freq_wd", "freq_wb", "freq_sd","freq_sb")
# show the first and last Lines of the Output
print(head(data_table))
print(tail(data_table))
```


```{r}

#initial parameters set to certain values 
init_wd <- 50
init_wb <- 50
init_sd <- 50
init_sb <- 50

decay_rate_wm <- 0.15
decay_rate_sm <- 0.25
s_wm <- 0.2
s_sm <- 0.3

max_gen <- 1000
no_replicates <- 50

#selection coefficients s and mutation rates m, varied (3 different values for both the weak and the strong strain)
s_values_wm <- c(0.10, 0.15, 0.20)
s_values_sm <- c(0.25, 0.30, 0.35)
m_values_wm <- c(0.004, 0.005, 0.006)
m_values_sm <- c(0.007, 0.008, 0.009)

#prepare empty data-tables to store results (one for each of the four mutations)
data_table <- c()
data_table_wd <- c()
data_table_wb <- c()
data_table_sd <- c()
data_table_sb <- c()

#----strong mutation----

#set up data frame to store the rescue results for the strong mutation, include selection coefficients and mutation rates of the strong mutation which should be stored as numeric values and the number of rescues for the strong beneficial and strong deleterious mutations (as whole numbers)
rescue_results <- data.frame(
  s_sm = numeric(),
  m_rate_sm = numeric(),
  replicate = integer(),
  rescued_sd = integer(),
  rescued_sb = integer()
)



# creating for loops to vary through the three different values for the strong selection coefficients and the strong mutation rates and the number of replicates we need
for (mval_sm in m_values_sm) {
  for (sval_sm in s_values_sm) {
    for (rep in 1:no_replicates) {
      
      # runing the simulation once (using the simulate_pop()function from before)
      one_run <- simulate_pop(
        init_wd, init_wb, init_sd, init_sb,
        decay_rate_wm, decay_rate_sm,
        sval_sm, s_wm, mval_sm, m_rate_wm, max_gen
      )
      
      # from the one_run, getting the final population-sizes of the strong deleterious and strong beneficial mutation
      pop <- one_run$population
      N_end_sd <- tail(pop[, "sd"], 1)
      N_end_sb <- tail(pop[, "sb"], 1)
      
      # saving the number of rescues, defined as the final population-size of the mutation being bigger than 0
      rescued_sd <- as.integer(N_end_sd > 0)
      rescued_sb <- as.integer(N_end_sb > 0)
      
      # using the function r bind to combine all results into the data frame rescue_results which we set up before
      rescue_results <- rbind(
        rescue_results,
        data.frame(
          s_sm = sval_sm,
          m_rate_sm = mval_sm,
          replicate = rep,
          rescued_sd = rescued_sd,
          rescued_sb = rescued_sb
        )
      )
    }
  }
}

# creating a summary of the rescue results that we get of the strong mutations by taking the mean of the number of rescues over the replicates
library(dplyr)
rescue_summary <- rescue_results %>%
  group_by(s_sm, m_rate_sm) %>%
  summarise(
    rescue_prob_sd = mean(rescued_sd),
    rescue_prob_sb = mean(rescued_sb),
    .groups = "drop"
  )

#loading the needed packages "tidyr" and "ggplot2"
library(tidyr)
library(ggplot2)



# plotting the heatmaps for the strong mutations, using s-values for the x-axis, mutation rates for the y axis and the colouring indicating rescue-probabiltiy
ggplot(rescue_summary, aes(x = factor(s_sm), y = factor(m_rate_sm), fill = rescue_prob_sd)) +
  geom_tile() +
  scale_fill_gradientn(
    colors = c("blue", "#FFB3B3", "red"),
    values = c(0, 0.3, 1),
    limits = c(0, 1),
    name = "Rescue Prob sd"
  ) +
  labs(
    title = "Heatmap: Rescue Probability of Strong Deleterious Mutation",
    x = "Strong selection coefficients",
    y = "Mutation rates (strong mutation)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
  )


ggplot(rescue_summary, aes(x = factor(s_sm), y = factor(m_rate_sm), fill = rescue_prob_sb)) +
  geom_tile() +
  scale_fill_gradientn(
    colors = c("blue", "#FFB3B3", "red"),
    values = c(0, 0.3, 1),
    limits = c(0, 1),
    name = "Rescue Prob sb"
  ) +
  labs(
    title = "Heatmap: Rescue Probability of Strong Beneficial Mutation",
    x = "Strong selection coefficients",
    y = "Mutation rates (strong mutation)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
  )
#set up data frame to store the rescue results for the weak mutation, include selection coefficients and mutation rates of the weak mutation which should be stored as numeric values and the number of rescues for the weak beneficial and strong deleterious mutations (as whole numbers)


rescue_results <- data.frame(
  s_wm = numeric(),
  m_rate_wm = numeric(),
  replicate = integer(),
  rescued_wd = integer(),
  rescued_wb = integer()
)


#creating for loops to vary through the three different values for the weak selection coefficients and the weak mutation rates and the number of replicates we need
for (mval_wm in m_values_wm) {
  for (sval_wm in s_values_wm) {
    for (rep in 1:no_replicates) {
      
      #runing the simulation once (using the simulate_pop()function from before)
      one_run <- simulate_pop(
        init_wd, init_wb, init_sd, init_sb,
        decay_rate_wm, decay_rate_sm,
        sval_wm, s_sm, mval_wm, m_rate_sm, max_gen
      )
      
      # from the one_run, getting the final population-sizes of the weak deleterious and strong beneficial mutation
      pop <- one_run$population
      N_end_wd <- tail(pop[, "wd"], 1)
      N_end_wb <- tail(pop[, "wb"], 1)
      
      #  saving the number of rescues, defined as the final population-size of the mutation being bigger than 0
      rescued_wd <- as.integer(N_end_wd > 0)
      rescued_wb <- as.integer(N_end_wb > 0)
      
      # using the function r bind to combine all results into the data frame rescue_results which we set up before
      rescue_results <- rbind(
        rescue_results,
        data.frame(
          s_wm = sval_wm,
          m_rate_wm = mval_wm,
          replicate = rep,
          rescued_wd = rescued_wd,
          rescued_wb = rescued_wb
        )
      )
    }
  }
}

# creating a summary of the rescue results that we get of the weak mutations by taking the mean of the number of rescues over the replicates
library(dplyr)
library(dplyr)
rescue_summary <- rescue_results %>%
  group_by(s_wm, m_rate_wm) %>%
  summarise(
    rescue_prob_wd = mean(rescued_wd),
    rescue_prob_wb = mean(rescued_wb),
    .groups = "drop"
  )

# loading needed packages "tidyr" and "ggplot2"
library(tidyr)
library(ggplot2)



# plotting the heatmaps for the weak mutations, using s-values for the x-axis, mutation rates for the y axis and the colouring indicating rescue-probabiltiy
ggplot(rescue_summary, aes(x = factor(s_wm), y = factor(m_rate_wm), fill = rescue_prob_wd)) +
  geom_tile() +
  scale_fill_gradientn(
    colors = c("blue", "#FFB3B3", "red"),
    values = c(0, 0.2, 1),
    limits = c(0, 1),
    name = "Rescue Prob wd"
  ) +
  labs(
    title = "Heatmap: Rescue Probability of Weak Deleterious Mutation",
    x = "Weak selection coefficients",
    y = "Mutation rates (weak mutation)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(t = 20, r = 10, b = 10, l = 10)
  )


ggplot(rescue_summary, aes(x = factor(s_wm), y = factor(m_rate_wm), fill = rescue_prob_wb)) +
  geom_tile() +
  scale_fill_gradientn(
    colors = c("blue", "#FFB3B3", "red"),
    values = c(0, 0.3, 1),
    limits = c(0, 1),
    name = "Rescue Prob wb"
  ) +
  labs(
    title = "Heatmap: Rescue Probability of Weak Beneficial Mutation",
    x = "Weak selection coefficients",
    y = "Mutation rates (weak mutation)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(t = 20, r = 10, b = 10, l = 10)              
  )




```
